// -*- mode: rust -*-
use std::str::FromStr;

use query;
use value;

grammar;

sep<A, S>: Vec<A> = {
    <v:(<A> S)*> <e:A> => {
        let mut v = v;
        v.push(e);
        v
    }
};

pub query: query::Query = {
    sep<process, bar> => query::Query(<>)
};

process: query::Process = {
    <ident> <expr*> => query::Process(<>),
};

expr: query::Expression = {
    <string> => query::Expression::Value(value::Value::String(<>)),
    <ident> => query::Expression::Value(value::Value::String(<>)),
    <integer> => query::Expression::Value(value::Value::I64(<>)),
    <closure> => query::Expression::Function(vec!["$".to_owned()], <>),
    <arg:ident> arrow <c:closure> => query::Expression::Function(vec![arg.to_owned()], c),
    open_paren <args:sep<ident, comma>> close_paren arrow <c:closure> => query::Expression::Function(args, c),
};

ident: String = r"[a-zA-Z_][a-zA-Z0-9_-]*" => <>.to_owned();
string: String = r#""[^"]*""# => <>[1..<>.len() - 1].to_owned();
integer: i64 = {
    r"[0-9]+" => i64::from_str(<>).unwrap(),
    "-" <r"[0-9]+"> => -i64::from_str(<>).unwrap(),
};
open_paren: () = "(" => ();
close_paren: () = ")" => ();
bar: () = "|" => ();
comma: () = "," => ();
arrow: () = "=>" => ();
closure: String = r"\{[^}]+\}" => <>[1..<>.len() - 1].to_owned();
